"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNonNullable = isNonNullable;
exports.default = convertToValidationMarker;

var _ValidationError = _interopRequireDefault(require("../ValidationError"));

var _pathToString = _interopRequireDefault(require("../util/pathToString"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isNonNullable(t) {
  return t !== null || t !== undefined;
}

function convertToValidationMarker(validationResult, level, context) {
  if (validationResult === true) return [];

  if (Array.isArray(validationResult)) {
    return validationResult.flatMap(child => convertToValidationMarker(child, level, context)).filter(isNonNullable);
  }

  if (typeof validationResult === 'string') {
    return convertToValidationMarker(new _ValidationError.default(validationResult, context.path && {
      paths: [context.path]
    }), level, context);
  }

  if (!(validationResult instanceof _ValidationError.default)) {
    // in order to accept the `ValidationErrorLike`, it at least needs to have
    // a `message` in the object
    if (typeof (validationResult === null || validationResult === void 0 ? void 0 : validationResult.message) !== 'string') {
      throw new Error("".concat((0, _pathToString.default)(context.path), ": Validator must return 'true' if valid or an error message as a string on errors"));
    } // this is the occurs when an object is returned that wasn't created with the
    // `ValidationErrorClass`. in this case, we want to convert it to a class


    return convertToValidationMarker(new _ValidationError.default(validationResult.message, validationResult), level, context);
  }

  var results = []; // Add an item at "root" level (for arrays, the actual array)

  if (validationResult.paths.length === 0) {
    results.push({
      type: 'validation',
      level: level || 'error',
      item: validationResult,
      path: []
    });
  } // Add individual items for each path


  return results.concat(validationResult.paths.map(path => ({
    type: 'validation',
    path,
    level: level || 'error',
    item: validationResult
  })));
}