"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateDocument;
exports.validateItem = validateItem;

var _types = require("@sanity/types");

var _typeString = _interopRequireDefault(require("./util/typeString"));

var _ValidationError = _interopRequireDefault(require("./ValidationError"));

var _Rule = _interopRequireDefault(require("./Rule"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var appendPath = (base, next) => base.concat(next);

var applyPathPrefix = (results, pathPrefix) => results.map(result => _objectSpread(_objectSpread({}, result), {}, {
  path: appendPath(pathPrefix, result.path)
}));

var resolveTypeForArrayItem = (item, candidates) => {
  var itemType = (0, _types.isTypedObject)(item) && item._type;

  var primitive = item === undefined || item === null || !itemType && (0, _typeString.default)(item).toLowerCase();

  if (primitive && primitive !== 'object') {
    return candidates.find(candidate => candidate.jsonType === primitive);
  }

  return candidates.find(candidate => {
    var _candidate$type;

    return ((_candidate$type = candidate.type) === null || _candidate$type === void 0 ? void 0 : _candidate$type.name) === itemType;
  }) || candidates.find(candidate => candidate.name === itemType) || candidates.find(candidate => candidate.name === 'object' && primitive === 'object');
};

function validateDocument(_x, _x2) {
  return _validateDocument.apply(this, arguments);
}

function _validateDocument() {
  _validateDocument = _asyncToGenerator(function* (doc, schema) {
    var documentType = schema.get(doc._type);

    if (!documentType) {
      console.warn('Schema type for object type "%s" not found, skipping validation', doc._type);
      return [];
    }

    try {
      return yield validateItem(doc, documentType, [], {
        document: doc
      });
    } catch (err) {
      console.error(err);
      return [{
        type: 'validation',
        level: 'error',
        path: [],
        item: new _ValidationError.default(err.message)
      }];
    }
  });
  return _validateDocument.apply(this, arguments);
}

function validateItem(item, type, path, context) {
  if (!type) {
    return Promise.resolve([{
      type: 'validation',
      level: 'error',
      path,
      item: new _ValidationError.default('Unable to resolve type for item', {
        paths: [path]
      })
    }]);
  }

  if (Array.isArray(item) && type.jsonType === 'array') {
    return validateArray(item, type, path, context);
  }

  if (typeof item === 'object' && item !== null && type.jsonType === 'object') {
    return validateObject(item, type, path, context);
  }

  return validatePrimitive(item, type, path, context);
}

function validateObject(_x3, _x4, _x5, _x6) {
  return _validateObject.apply(this, arguments);
}

function _validateObject() {
  _validateObject = _asyncToGenerator(function* (obj, type, path, context) {
    if (!type) {
      return [];
    }

    if (typeof type.validation === 'function') {
      throw new Error("Schema type \"".concat(type.name, "\"'s `validation` was not run though `inferFromSchema`"));
    } // Validate actual object itself


    var objChecks = [];

    if (Array.isArray(type.validation)) {
      objChecks = type.validation.map( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (rule) {
          var ruleResults = yield rule.validate(obj, {
            parent: context.parent,
            document: context.document,
            path,
            type
          });
          return applyPathPrefix(ruleResults, path);
        });

        return function (_x15) {
          return _ref.apply(this, arguments);
        };
      }());
    } // Validate fields within object


    var fieldRules = (type.validation || []).map(rule => rule._fieldRules).filter(Boolean).reduce(Object.assign, {});
    var fieldChecks = type.fields.map( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (field) {
        // field validation from the enclosing object type
        var fieldValidation = fieldRules[field.name];

        if (!fieldValidation) {
          return [];
        }

        var fieldPath = appendPath(path, field.name);
        var fieldValue = obj[field.name];
        var result = yield fieldValidation(new _Rule.default()).validate(fieldValue, {
          parent: obj,
          document: context.document,
          path: fieldPath,
          type: field.type
        });
        return applyPathPrefix(result, fieldPath);
      });

      return function (_x16) {
        return _ref2.apply(this, arguments);
      };
    }());
    var fieldTypeChecks = type.fields.map(field => {
      var _field$type;

      // field validation from field type
      var fieldPath = appendPath(path, field.name);
      var fieldValue = obj[field.name];

      if (!((_field$type = field.type) !== null && _field$type !== void 0 && _field$type.validation)) {
        return [];
      }

      return validateItem(fieldValue, field.type, fieldPath, {
        parent: obj,
        document: context.document,
        path: fieldPath,
        type: field.type
      });
    });
    var results = yield Promise.all([...objChecks, ...fieldChecks, ...fieldTypeChecks]);
    return results.flat();
  });
  return _validateObject.apply(this, arguments);
}

function validateArray(_x7, _x8, _x9, _x10) {
  return _validateArray.apply(this, arguments);
}

function _validateArray() {
  _validateArray = _asyncToGenerator(function* (items, type, path, options) {
    if (!type) {
      return [{
        type: 'validation',
        level: 'error',
        path,
        item: new _ValidationError.default('Unable to resolve type for array', {
          paths: [path]
        })
      }];
    } // Validate actual array itself


    var arrayChecks = [];

    if (Array.isArray(type.validation)) {
      arrayChecks = type.validation.map( /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(function* (rule) {
          var ruleResults = yield rule.validate(items, {
            parent: options.parent,
            document: options.document,
            path,
            type
          });
          return applyPathPrefix(ruleResults, path);
        });

        return function (_x17) {
          return _ref3.apply(this, arguments);
        };
      }());
    } // Validate items within array


    var itemChecks = items.map((item, i) => {
      var pathSegment = (0, _types.isKeyedObject)(item) ? {
        _key: item._key
      } : i;
      var itemType = resolveTypeForArrayItem(item, type.of);
      var itemPath = appendPath(path, [pathSegment]);
      return validateItem(item, itemType, itemPath, {
        parent: items,
        document: options.document,
        path: itemPath
      });
    });
    var result = yield Promise.all([...arrayChecks, ...itemChecks]);
    return result.flat();
  });
  return _validateArray.apply(this, arguments);
}

function validatePrimitive(_x11, _x12, _x13, _x14) {
  return _validatePrimitive.apply(this, arguments);
}

function _validatePrimitive() {
  _validatePrimitive = _asyncToGenerator(function* (item, type, path, context) {
    if (!type) {
      return [{
        type: 'validation',
        level: 'error',
        path,
        item: new _ValidationError.default('Unable to resolve type for item', {
          paths: [path]
        })
      }];
    }

    if (!Array.isArray(type.validation)) {
      return [];
    }

    var resolved = yield Promise.all(type.validation.map( /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(function* (rule) {
        var currRuleResults = yield rule.validate(item, {
          parent: context.parent,
          document: context.document,
          path
        });
        return applyPathPrefix(currRuleResults, path);
      });

      return function (_x18) {
        return _ref4.apply(this, arguments);
      };
    }()));
    return resolved.flat();
  });
  return _validatePrimitive.apply(this, arguments);
}